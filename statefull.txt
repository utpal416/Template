---
plugin: rest

# API 1: Unblock Device
- path: /v1/api/cards/accounts/:accountId/devices/:deviceId/unblock-device
  method: POST
  response:
    statusCode: 200
    headers:
      Content-Type: application/json
    scriptFile: card-unblock-script.js

# API 2: Get Control Status
- path: /v1/api/cards/accounts/:accountId/devices/:deviceId/control-status
  method: GET
  response:
    statusCode: 200
    headers:
      Content-Type: application/json
    scriptFile: card-status-script.js

# API 3: Block Device
- path: /v1/api/cards/accounts/:accountId/devices/:deviceId/block-device
  method: POST
  response:
    statusCode: 202
    headers:
      Content-Type: application/json
    scriptFile: card-block-script.js

-----------------unblock.js

    // ============================================
// UNBLOCK DEVICE API - Sets card to UNBLOCKED state
// ============================================

// Extract path parameters
var accountId = context.request.pathParams.accountId || "";
var deviceId = context.request.pathParams.deviceId || "";

// Create storage key
var stateKey = "card-state-" + accountId + "-" + deviceId;

// Generate UUID for this operation
function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0;
        var v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

var operationId = generateUUID();

// Store the unblocked state
var cardState = {
    "status": "COMPLETED",
    "cardBlock": "OFF",
    "operationId": operationId
};

// Save state to store
stores.save(stateKey, JSON.stringify(cardState));

// Return 200 OK response
var response = {
    "data": {
        "id": operationId,
        "type": "unblockDeviceV1",
        "attributes": {
            "status": "COMPLETED",
            "cardBlock": "OFF"
        }
    }
};

respond()
    .withStatusCode(200)
    .withHeader("Content-Type", "application/json")
    .withContent(JSON.stringify(response, null, 2));

    ---------------- card block 

    // ============================================
// BLOCK DEVICE API - Sets card to BLOCKED state
// ============================================

// Extract path parameters
var accountId = context.request.pathParams.accountId || "";
var deviceId = context.request.pathParams.deviceId || "";

// Create storage key
var stateKey = "card-state-" + accountId + "-" + deviceId;

// Generate UUID for this operation
function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0;
        var v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

var operationId = generateUUID();

// Store the blocked state
var cardState = {
    "status": "COMPLETED",
    "cardBlock": "ON",
    "operationId": operationId
};

// Save state to store
stores.save(stateKey, JSON.stringify(cardState));

// Return 202 Accepted response
var response = {
    "data": {
        "id": operationId,
        "type": "blockDeviceV1",
        "attributes": {
            "status": "ACCEPTED"
        }
    }
};

respond()
    .withStatusCode(202)
    .withHeader("Content-Type", "application/json")
    .withContent(JSON.stringify(response, null, 2));


    ------------------card control
    // ============================================
// GET CONTROL STATUS API - Returns current card state
// ============================================

// Extract path parameters
var accountId = context.request.pathParams.accountId || "";
var deviceId = context.request.pathParams.deviceId || "";

// Create storage key
var stateKey = "card-state-" + accountId + "-" + deviceId;

// Default state (unblocked) if no previous state exists
var defaultState = {
    "status": "COMPLETED",
    "cardBlock": "OFF",
    "operationId": "00000000-0000-0000-0000-000000000000"
};

// Retrieve state from store
var storedState = stores.load(stateKey);
var cardState;

if (storedState) {
    try {
        cardState = JSON.parse(storedState);
    } catch (e) {
        cardState = defaultState;
    }
} else {
    cardState = defaultState;
}

// Build response
var response = {
    "data": {
        "id": cardState.operationId,
        "type": "getControlStatusV1",
        "attributes": {
            "status": cardState.status,
            "cardBlock": cardState.cardBlock
        }
    }
};

respond()
    .withStatusCode(200)
    .withHeader("Content-Type", "application/json")
    .withContent(JSON.stringify(response, null, 2));


__________

// Extract path parameters
const customerId = context.request.pathParams.customerId;
const accountId = context.request.pathParams.accountId;

// Get query parameters for pagination (optional)
const queryParams = context.request.queryParams;
const page = queryParams.page ? parseInt(queryParams.page) : 1;
const pageSize = queryParams.pageSize ? parseInt(queryParams.pageSize) : 20;

// Retrieve stored payments
const storeKey = customerId + '-' + accountId;
const store = stores.open('payments-store');
const storedData = store.load(storeKey);

let payments = [];
if (storedData) {
    payments = JSON.parse(storedData);
}

// Calculate pagination
const totalElements = payments.length;
const totalPages = Math.ceil(totalElements / pageSize);
const startIndex = (page - 1) * pageSize;
const endIndex = Math.min(startIndex + pageSize, totalElements);
const pagedPayments = payments.slice(startIndex, endIndex);

// Build response
const response = {
    meta: {
        totalElements: totalElements,
        totalPages: totalPages,
        pageSize: pageSize,
        pageNumber: page,
        numberOfElements: pagedPayments.length
    },
    data: pagedPayments,
    links: {
        self: '/customers/' + customerId + '/consumerCardAccounts/' + accountId + '/payments?page=' + page,
        first: '/customers/' + customerId + '/consumerCardAccounts/' + accountId + '/payments?page=1',
        last: '/customers/' + customerId + '/consumerCardAccounts/' + accountId + '/payments?page=' + totalPages
    }
};

// Send response
respond()
    .withStatusCode(200)
    .withData(JSON.stringify(response))
    .withHeader('Content-Type', 'application/json');

_________

// Extract path parameters
const customerId = context.request.pathParams.customerId;
const accountId = context.request.pathParams.accountId;

// Parse request body
const requestBody = JSON.parse(context.request.body);
const attributes = requestBody.data.attributes;

// Generate payment ID and reference number
const timestamp = new Date().getTime();
const paymentId = '' + (10000000 + Math.floor(Math.random() * 90000000));
const referenceNumber = '' + (1000000000 + Math.floor(Math.random() * 900000000));

// Create current timestamp in required format
const now = new Date();
const requestedOn = now.toISOString().replace('Z', '-0400');

// Build payment object
const payment = {
    id: paymentId,
    type: requestBody.data.type,
    attributes: {
        paymentId: paymentId,
        fromAccount: "BOFAM",
        paymentReferenceNumber: referenceNumber,
        amount: {
            currency: attributes.amount.currency,
            amount: attributes.amount.amount
        },
        requestedOn: requestedOn,
        paymentDate: attributes.paymentDate,
        statusUpdateDate: attributes.paymentDate,
        status: "SCHEDULED",
        channel: "PHONE",
        projectedCreditDate: getNextDay(attributes.paymentDate),
        isInternalPayment: true,
        paymentOptionType: attributes.optionType,
        externalAccountType: "CHECKING",
        externalAccountId: attributes.externalAccountId
    }
};

// Helper function to get next day
function getNextDay(dateStr) {
    const date = new Date(dateStr);
    date.setDate(date.getDate() + 1);
    return date.toISOString().split('T')[0];
}

// Store the payment
const storeKey = customerId + '-' + accountId;
const store = stores.open('payments-store');
const existingData = store.load(storeKey);

let payments = [];
if (existingData) {
    payments = JSON.parse(existingData);
}

payments.push(payment);
store.save(storeKey, JSON.stringify(payments));

// Build response
const response = {
    data: payment,
    links: {
        self: '/customers/' + customerId + '/consumerCardAccounts/' + accountId + '/payments/' + paymentId
    }
};

// Send response
respond()
    .withStatusCode(201)
    .withData(JSON.stringify(response))
    .withHeader('Content-Type', 'application/json');
